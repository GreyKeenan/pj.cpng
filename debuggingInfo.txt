

decompressed:

0x1
0x0 0x0 0x0 0xff
0x0 0x0 0x0 0x0
0x15 0xc 0x12 0x0
0x5 0x10 0x1a 0x0
0x2
0x0 0x0 0x0 0x0
0x15 0xc 0x12 0x0
0x5 0x10 0x1a 0x0
0x11 0xfe 0xf9 0x0
0x2
0x0 0x0 0x0 0x15
0xc 0x12 0x0 0x5
0x11 0xfe 0xf9 0x0
0x6f 0x8 0x4b 0x0
0x2
0x5 0x10 0x1a 0x0
0x11 0xfe 0xf9 0x0
0x6f 0x8 0x4b 0x0
0x32 0x2f 0x31 0x0


defiltered:

1
0x0  0x0  0x0  0xff
0x0  0x0  0x0  0xff
0x15  0xc  0x12  0xff
0x1a  0x1c  0x2c  0xff
2
0x0  0x0  0x0  0xff
0x15  0xc  0x12  0xff
0x1a  0x1c  0x2c  0xff
0x2b  0x1a  0x25  0xff
2
0x0  0x0  0x0  0x14
0x21  0x1e  0x12  0x4
0x2b  0x1a  0x25  0xff
0x9a  0x22  0x70  0xff
2
0x5  0x10  0x1a  0x14
0x32  0x1c  0xb  0x4
0x9a  0x22  0x70  0xff
0xcc  0x51  0xa1  0xff



expected defiltered:

00 00 00 ff
00 00 00 ff
15 0c 12 ff
1a 1c 2c ff

00 00 00 ff
15 0c 12 ff
1a 1c 2c ff
2b 1a 25 ff

15 0c 12 ff !
1a 1c 2c ff !
2b 1a 25 ff
9a 22 70 ff

15 0c 12 ff !
1a 1c 2c ff !
9a 22 70 ff
cc 51 a1 ff






bits:

00110001) value: 0x1

00110000) value: 0x0
00110000) value: 0x0
00110000) value: 0x0
111111111) value: 0xff
0000001) value: 0x101
00011]f l3, d4
rpt:0 rpt:0 rpt:0 
00110000) value: 0x0
01000101) value: 0x15
00111100) value: 0xc
01000010) value: 0x12
00110000) value: 0x0
00110101) value: 0x5
01000000) value: 0x10
01001010) value: 0x1a
00110000) value: 0x0

00110010) value: 0x2

0001001) value: 0x109
1]l 00111]f 00]d l12, d13
rpt:0 rpt:0 rpt:0 rpt:0 rpt:15 rpt:c rpt:12 rpt:0 rpt:5 rpt:10 rpt:1a rpt:0 
01000001) value: 0x11
111111110) value: 0xfe
111111001) value: 0xf9
00110000) value: 0x0

00110010) value: 0x2

0000110) value: 0x106
01001]f 100]d l8, d29		<-- this is where the incorrect bytes start. Why? If the distanceBack was 26, it would be correct.
				Its not like the 5-bit int is offset by a bit or something. This would echo to more errors below, and it would be off by too much
				are the extra distance bits flipped somehow??
				This would track. All of the other distance-extra-bits are palindromes, and if this was reversed it would result in the correct values.
				Why would it need to be reversed though? All the other bits are MSb first. This one isnt for some reason?
					p12 of DEFLATE spec explicitly states that extra bits are MSb first

					but it cant be reversed for other bit collection stuff. That would still break everything??
					OR CAN IT!??
						theres only 1 length code with extra bits, and its only 1 so order doesnt matter.

					OH!! Its the fucking annoying DEFLATE terminology thing again (totally not my fault ;I )
						"stored with the most significant bit first" DOES NOT MEAN "read" with the most significant bit first. 

						I was going to ask "why are the 5-bit distance ints not reversed then?" BUT theyre 'codes' not 'ints', even though they correspond.
							and codes are read in the opposite bit order, of course, duh, you dummy, you moron
rpt:0 rpt:0 rpt:0 rpt:15 rpt:c rpt:12 rpt:0 rpt:5 
0000010) value: 0x102
00111]f 00]d l4, d13
rpt:11 rpt:fe rpt:f9 rpt:0 
10011111) value: 0x6f
00111000) value: 0x8
01111011) value: 0x4b
00110000) value: 0x0

00110010) value: 0x2

0000010) value: 0x102
01010]f 0110]d l4, d39
rpt:5 rpt:10 rpt:1a rpt:0 
0000110) value: 0x106
00111]f 00]d l8, d13
rpt:11 rpt:fe rpt:f9 rpt:0 rpt:6f rpt:8 rpt:4b rpt:0 
01100010) value: 0x32
01011111) value: 0x2f
01100001) value: 0x31
00110000) value: 0x0
0000000) value: 0x100
