
Overview
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

major steps to deciphering PNG image
	1. dechunking
	2. decompressing
	3. defiltering
	4. de-scanline-ing
	5. (potentially) de-interlacing


Dechunking
==================================================

reading image context data, like how it is formatted or its dimensions
PNGs split data into chunks. IDAT chunks contain the compressed data, potentially split btwn multiple chunks


Decompressing
==================================================

Compression method 0 is the only standardized allowed method. It is using ZLIB compression method 8, which uses DEFLATE.


Defiltering
==================================================

filter method 0 is the only alloewd method.

Each scanline is prefixed by an identifier for 1 of five "filter types" within filter method 0.
	0: none
	1: sub
	2: up
	3: average
	4: paeth

filter functions apply to bytes, not pixels.
the filtering functions are concerned with 4 diffent bytes:
	- 'x': the current byte being filtered
	- 'a': the byte ~~preceding~~ x (before 'a' was filtered)
	- 'b': the byte *above* x, aka in the previous scanline, (before 'b' was filtered)
	- 'c': 'a' of 'b', before 'c' was filtered
	if any of these bytes are out of the bounds of the sequence, eg first byte of a scanline or first scanline, they are equal to 0

	NOTE: the preceding byte is NOT NECESSARILY the immediately prior byte!!!
		it is the byte corresponding to x in the previous pixel, not the previous byte
		UNLESS bitdepth < 8, in which case it is just the previous byte


de-scanline-ing
==================================================

pixels in scanlines are packed without wasting bits between each other.
scanlines themselves always start on a byte boundary, though
	the bits between these gaps need not be 0. They can be anything.
scanlines are all the same length

when sub-byte pixels, the leftmost (first) sample starts in the high-order bits of the byte
	sub-byte samples are not permitted combinations
when multi-byte pixels/samples, its MSB byte first


PNG Anatomy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

(multi-byte values are big-endian)

8B PNG Header:
	0x89
	'P'
	'N'
	'G'
	0x0D
	0x0A
	0x1A
	0x0A
IHDR Chunk : Image Header
	4B length: 13
	4B type: 'I', 'H', 'D', 'R'
	[length]B data:
		4B width
			!0
		4B height
			!0
		1B bitDepth
			generally: 1, 2, 4, 8, 16

			represents bits per SAMPLE (not per pixel)
				so, if rgba & '8', is rgba=4 * 8 = 32 bits per pixel

			only certain values are valid with color types:
				colourType : bitDepth
				0	: 1,2,4,8,16
				3	: 1,2,4,8
				2,4,6	: 8,16

		1B colourType
			0, 2, 3, 4, 6
				greyscale
				truecolor
				indexed-color
				greyscale alpha
				truecolor alpha
		1B compressionMethod = 0
		1B filterMethod = 0
		1B interlaceMethod
			0, 1 : none, Adam7
	4B CRC
	
n Chunks
	Chunk:
		4B length
			< 80_00_00_00
		4B type
			4 1-byte chars
				only a-z or A-Z

			capitalization encodes meaning
				B[0]
					uppercase = CRITICAL
					lowercase = ANCILLARY
				B[1]
					uppercase = PUBLIC CHUNK
					lowercase = PRIVATE CHUNK

					public is defined by official PNG standards, private is specific to some environment
				B[2]
					uppercase = ACCEPTABLE
					lowercase = RESERVED: ERROR
				B[3]
					upparcase = NOT SAFE TO COPY
					lowercase = SAFE TO COPY
						
					irrelevant for decoders
					? whether the chunk can be copied by a PNG editor if its unrecognized to the new PNG ?

			"capitalization" is defined by checking the corresponding ASCII capitalization bit, not by checking the actual letter ranges.
				1 = lowercase, 0 = uppercase / as per ascii

		[length]B data
		
		4B CRC Cyclic Redundancy Code
			calculated over "type" & "data"
			to check for corruption of the data

	Chunk Ordering:
		I am only mentioning the CRITICAL chunks here

		IHDR:
			only 1
			always FIRST
			(see above)
		PLTE:
			only 1
			appears before IDAT
		IDAT:
			multiple allowed
			appear consecutively
		IEND:
			only 1
			always LAST
			(see below)
IEND Chunk
	4B length: 0
	4B type: IHDR
	[length]B data
	4B CRC


IDAT
==================================================

data within idats, when appended together, is a zlib-compressed stream

PLTE
==================================================



Zlib
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

2B zlib header
	1B CMF
		4b compression method = 8 (for PNGs)
		4b additional info, depedning on prev 4 bits
			when compression method == 8:
				is log2(lz77_window_size - 8)
				CANNOT be > 7
	1B FLG flags
		5b validation value
			ensures that these 2 bytes, as a 16bit uint, MSB being CMF, is divisible by 31 (x % 31 = 0)
		1b FDICT = 0 (for PNGs)
			if 1, indicates presence of a preset dict
		2b FLEVEL
			the level of compression the compressor used

			irrelevant for decompressors
0|4B DICT
	(only present if FDICT flag bit == 1)
	never present for PNGs
	identifies the preset dict that was used in compression
	is an ADLER32 of the dict

(n)B data
	a stream of data following the DEFLATE format

4B ADLER32
	checksum of decompressed data, to ensure decompression was correct


DEFLATE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

consists of a series of blocks:

3b block header
	1b isLastBlock
	2b compressionType
		00 = uncompressed
		01 = fixed
		10 = dynamic
		11 = reserved, error
(corresponding data sequence to compressionType)


uncompressed
==================================================

(LSB first:)

2B length
2B 1s complement of length, for validataion

[length]B raw bytes of data
