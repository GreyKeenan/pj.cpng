
PNG Anatomy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

(multi-byte values are big-endian)

8B PNG Header:
	0x89
	'P'
	'N'
	'G'
	0x0D
	0x0A
	0x1A
	0x0A
IHDR Chunk : Image Header
	4B length: 13
	4B type: 'I', 'H', 'D', 'R'
	[length]B data:
		4B width
			!0
		4B height
			!0
		1B bitDepth
			generally: 1, 2, 4, 8, 16

			represents bits per SAMPLE (not per pixel)
				so, if rgba & '8', is rgba=4 * 8 = 32 bits per pixel

			only certain values are valid with color types:
				colourType : bitDepth
				0	: 1,2,4,8,16
				3	: 1,2,4,8
				2,4,6	: 8,16

		1B colourType
			0, 2, 3, 4, 6
				greyscale
				truecolor
				indexed-color
				greyscale alpha
				truecolor alpha
		1B compressionMethod = 0
		1B filterMethod = 0
		1B interlaceMethod
			0, 1 : none, Adam7
	4B CRC
	
n Chunks
	Chunk:
		4B length
			< 80_00_00_00
		4B type
			4 1-byte chars
				only a-z or A-Z

			capitalization encodes meaning
				B[0]
					uppercase = CRITICAL
					lowercase = ANCILLARY
				B[1]
					uppercase = PUBLIC CHUNK
					lowercase = PRIVATE CHUNK

					public is defined by official PNG standards, private is specific to some environment
				B[2]
					uppercase = ACCEPTABLE
					lowercase = RESERVED: ERROR
				B[3]
					upparcase = NOT SAFE TO COPY
					lowercase = SAFE TO COPY
						
					irrelevant for decoders
					? whether the chunk can be copied by a PNG editor if its unrecognized to the new PNG ?

			"capitalization" is defined by checking the corresponding ASCII capitalization bit, not by checking the actual letter ranges.
				1 = lowercase, 0 = uppercase / as per ascii

		[length]B data
		
		4B CRC Cyclic Redundancy Code
			calculated over "type" & "data"
			to check for corruption of the data

	Chunk Ordering:
		I am only mentioning the CRITICAL chunks here

		IHDR:
			only 1
			always FIRST
			(see above)
		PLTE:
			only 1
			appears before IDAT
		IDAT:
			multiple allowed
			appear consecutively
		IEND:
			only 1
			always LAST
			(see below)
IEND Chunk
	4B length: 0
	4B type: IHDR
	[length]B data
	4B CRC


IDAT
==================================================

data within idats, when appended together, is a zlib-compressed stream

PLTE
==================================================



Zlib
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

2B zlib header
	1B CMF
		4b compression method = 8 (for PNGs)
		4b additional info, depedning on prev 4 bits
			when compression method == 8:
				is log2(lz77_window_size - 8)
				CANNOT be > 7
	1B FLG flags
		5b validation value
			ensures that these 2 bytes, as a 16bit uint, MSB being CMF, is divisible by 31 (x % 31 = 0)
		1b FDICT = 0 (for PNGs)
			if 1, indicates presence of a preset dict
		2b FLEVEL
			the level of compression the compressor used

			irrelevant for decompressors
0|4B DICT
	(only present if FDICT flag bit == 1)
	never present for PNGs
	identifies the preset dict that was used in compression
	is an ADLER32 of the dict

(n)B data
	a stream of data following the DEFLATE format

4B ADLER32
	checksum of decompressed data, to ensure decompression was correct


DEFLATE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

consists of a series of blocks:

3b block header
	1b isLastBlock
	2b compressionType
		00 = uncompressed
		01 = fixed
		10 = dynamic
		11 = reserved, error
(corresponding data sequence to compressionType)


uncompressed
==================================================

(LSB first:)

2B length
2B 1s complement of length, for validataion

[length]B raw bytes of data
